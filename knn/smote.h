#ifndef _RI_2015_1_KNN_SMOTE_H_
#define _RI_2015_1_KNN_SMOTE_H_

#include <cstdlib>
#include <iostream>
#include <queue>
#include <unordered_map>
#include "k_nearest_neighbours.h"
#include "../base/query.h"

namespace knn {

class Smote {
 public:
  //|k| is the amount of kept neighbours by |knn|. |relevance_level| is the
  // degree of relevance we will oversample.
  Smote(const ::base::Query& sample_query, unsigned relevance_level,
        unsigned k);

  const ::base::Query& real_relevants() const {
    return real_relevants_;
  };

  const ::base::Query& synthetic_relevants() const {
    return synthetic_relevants_;
  };

  // Initializes |real_relevants| based on |relevance_level_|. Returns true if 2
  // or more documents with |relevance_level_| exist within |query|.
  bool Initialize(const ::base::Query& query);

  // Populates |synthetic_relevants_| with |extra_count| more documents. If
  // |with_feedback| is set, the synthetic samples are also taken into account.
  void Populate(double extra_percentage, bool with_feedback);

  // Adds the documents in |synthetic_relevants_| to |query|.
  void AugmentQuery(::base::Query& query);

 private:
  // Generates a sample between |d1| and |d2| and stores it in
  // |synthetic_relevants_|.
  void GenerateSyntheticSample(const ::base::Document& d1,
                               const ::base::Document& d2);

  // Updates the neighbourhood relations to every one of the |real_size| first
  // relevants, excepting those in |exceptions|.
  void UpdateNeighbourhoods(unsigned real_size,
                            std::pair<unsigned, unsigned> exceptions);

  // The relevant documents extracted from a given query.
  ::base::Query real_relevants_;

  // The relevants generated by smoting the data.
  ::base::Query synthetic_relevants_;

  // The level of relevance we are oversampling.
  unsigned relevance_level_;

  // The structure to store the nearest neighbours of the given queries.
  KNearestNeighbours knn_;
};

}  // namespace knn

#endif
