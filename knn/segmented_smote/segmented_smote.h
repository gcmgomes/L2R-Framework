// This class implements Segmented Smote. In this algorithm, we apply Smote's
// Connecting Line Segment idea with any informativeness metric in the attempt
// to give the synthetic oversampling a means by which it can measure how well
// each candidate point will influence the initial dataset.
// As a first effort, we implement Smote using MODAL's information heuristic to
// divide the Connecting Line Segments into isometrical subsegments. The best
// segments are selected and a random point within it is selected as a synthetic
// sample.
// After constructed, the object will be ready for use. Simply call Populate
// with the desired parameters and the synthetic samples will be generated. To
// add them to your query, use the AugmentQuery method.

#ifndef _RI_2015_1_KNN_SEGMENTED_SMOTE_SEGMENTED_SMOTE_H_
#define _RI_2015_1_KNN_SEGMENTED_SMOTE_SEGMENTED_SMOTE_H_

#include <cstdlib>
#include <iostream>
#include <queue>
#include <unordered_map>
#include "segmentation_metadata.h"
#include "smote_segmenter.h"
#include "../k_nearest_neighbours.h"
#include "../../base/query.h"
#include "../../util/discretizer.h"

namespace knn {

namespace segmented_smote {

class SegmentedSmote {
 public:
  //|k| is the amount of kept neighbours by |knn|. |relevance_level| is the
  // degree of relevance we will oversample. |bin_count| is the discretization
  // level.
  SegmentedSmote(const ::base::Query& query, unsigned relevance_level,
                 unsigned k, ::util::Discretizer::Mode mode, unsigned bin_count);

  const ::base::Query& real_relevants() const {
    return real_relevants_;
  };

  const ::base::Query& synthetic_relevants() const {
    return synthetic_relevants_;
  };

  // Populates |synthetic_relevants_| with |extra_percentage| more documents. If
  // |with_feedback| is set, the synthetic samples are also taken into account.
  // |extra_percentage| is such that, if set to 100, will generate as many
  // synethetic samples as we have real samples.
  void Populate(double extra_percentage, bool with_feedback);

  // Adds the documents in |synthetic_relevants_| to |query|.
  void AugmentQuery(::base::Query& query);

 private:
  // Initializes |real_relevants| based on |relevance_level_|. Returns true if 2
  // or more documents with |relevance_level_| exist within |query|.
  bool Initialize(const ::base::Query& query);

  // Generates a sample between |d1| and |d2| and stores it in
  // |synthetic_relevants_|.
  void GenerateSyntheticSample(const ::base::Document& d1,
                               const ::base::Document& d2);

  // Updates the neighbourhood relations to every one of the |real_size| first
  // relevants, excepting those in |exceptions|.
  void UpdateNeighbourhoods(unsigned real_size,
                            std::pair<unsigned, unsigned> exceptions);

  // The relevant documents extracted from a given query.
  ::base::Query real_relevants_;

  // The relevants generated by SMOTE'ing the data.
  ::base::Query synthetic_relevants_;

  // The level of relevance we are oversampling.
  unsigned relevance_level_;

  // The structure to store the nearest neighbours of the given queries.
  ::knn::KNearestNeighbours knn_;

  // Discretization utility.
  ::util::Discretizer discretizer_;

  // The structure to support MODAL operations.
  SegmentationMetadata segmentation_metadata_;

  // Object to handle segment separation and optimal discovery.
  std::unique_ptr<SmoteSegmenter> smote_segmenter_;
};

}  // namespace segmented_smote

}  // namespace knn

#endif
